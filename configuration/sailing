#!/bin/bash
#
# sailing	Starts sailing services
#
# chkconfig: 2345 95 10
# description: Sailing contains all sailing services
#
### BEGIN INIT INFO
# Provides:          sailing
# Required-Start:    $local_fs $network $named $remote_fs
# Should-Start:      
# Required-Stop:
# Should-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: The sailing service
# Description:       Start all sailing services required for this instance
### END INIT INFO

# Source function library.
. /etc/init.d/functions

RETVAL=0

SERVERS_DIR=/home/sailing/servers
cd "${SERVERS_DIR}"
JAVA_START_INSTANCES="$(find * -type d -prune)"
GIT_REPOSITORY=/home/sailing/code
APACHE_CONFIG_DIR=/etc/httpd/conf.d
APACHE_INTERNALS_CONFIG_FILE="$APACHE_CONFIG_DIR/001-internals.conf"
EC2_METADATA_CMD=/opt/aws/bin/ec2-metadata
REBOOT_INDICATOR=/var/run/is-rebooted

echo "Executing with $1 at `date`" >>/var/log/sailing.err

start_tmux() {
	su - sailing -c "/home/sailing/bin/tmuxConsole.sh unattended"
	success
}

start_servers() {
        if which $EC2_METADATA_CMD && $EC2_METADATA_CMD -d | sed "s/user-data\: //g" | grep "^image-upgrade$"; then
          echo "Found image-upgrade in EC2 user data; upgrading image, then probably shutting down for AMI creation depending on the no-shutdown user data string..." >>/var/log/sailing.err
          $GIT_REPOSITORY/configuration/imageupgrade.sh
        else
          echo "No image-upgrade request found in EC2 user data $($EC2_METADATA_CMD -d); proceeding with regular server launch..." >>/var/log/sailing.err
	  echo "Servers to launch: ${JAVA_START_INSTANCES}" >>/var/log/sailing.err
	  NUMBER_OF_INSTANCES=`echo "$JAVA_START_INSTANCES" | wc -w`
          FIRST_SERVER=`echo $JAVA_START_INSTANCES | awk '{print $1;}'`
          if [ -f "${REBOOT_INDICATOR}" ]; then
	    echo "This is a re-boot. No EC2 user data is evaluated for server configuration; no server configuration is performed. Only configured applications are launched." >>/var/log/sailing.err
	    for conf in ${JAVA_START_INSTANCES}; do
	      start_server ${conf}
	    done
	  else
	    echo "This is a first-time boot. EC2 user data is evaluated for potential application deployment and configuration; reverse proxy entries may be created, and applications are launched." >>/var/log/sailing.err
	    if [ ${NUMBER_OF_INSTANCES} -gt 1 ]; then
	      echo "More than one server cannot be configured from user data; only configuring ${FIRST_SERVER}" >>/var/log/sailing.err
	    fi
	    configure_and_start_server "${FIRST_SERVER}"
	    create_basic_httpd_config
	    reload_httpd
	    echo 1 >"${REBOOT_INDICATOR}"
	  fi
	fi
}

# Call with the server directory name (not the full path, just a single element from ${JAVA_START_INSTANCE}) as parameter
# Example:        start_server server
start_server() {
  local conf="$1"
  echo "Starting server ${conf} with SERVER_NAME=${SERVER_NAME}" >>/var/log/sailing.err
  su - sailing -c "cd ${SERVERS_DIR}/${conf} && SERVER_NAME=${SERVER_NAME} ./start" 2>>/var/log/sailing.err >>/var/log/sailing.err
}

# Call with the server directory name (not the full path, just a single element from ${JAVA_START_INSTANCE}) as parameter
# Example:        configure_and_start_server server
# This is expected to be called only in case there is only one server to configure; otherwise, the same EC2 user data
# would get applied to all application configurations which would not be a good idea.
configure_and_start_server() {
  conf="$1"
  mkdir -p "${SERVERS_DIR}/${conf}" >/dev/null 2>/dev/null
  NUMBER_OF_INSTANCES=`echo "$JAVA_START_INSTANCES" | wc -w`
  MINIMUM_MEMORY_IN_MB=2000
  MEM_TOTAL=`cat /proc/meminfo  | grep MemTotal | awk '{print $2;}'`
  MEMORY_COMPUTED=$(( ${MEM_TOTAL} / 1024 * 3 / 4 - 1500 / 1 ))
  MEMORY_PER_INSTANCE_IN_MB=$(( $MEMORY_COMPUTED < $MINIMUM_MEMORY_IN_MB ? $MINIMUM_MEMORY_IN_MB : $MEMORY_COMPUTED ))
  echo "Using ${MEMORY_PER_INSTANCE_IN_MB}MB as default heap size per instance." >>/var/log/sailing.err
  local ENV_SH="${SERVERS_DIR}/$conf/env.sh"
  # ensure that if this *created* env.sh that it's owned by the correct user:
  chown sailing "${ENV_SH}"
  chgrp sailing "${ENV_SH}"
  su - sailing -c "cd ${SERVERS_DIR}/${conf} && ${GIT_REPOSITORY}/java/target/refreshInstance.sh auto-install" 2>>/var/log/sailing.err >>/var/log/sailing.err
  (
    # execute env.sh in a subshell which now has the same set of variables that the server will see
    source "${ENV_SH}"
    if [ -z $MEMORY ]; then
      echo "MEMORY=\"${MEMORY_PER_INSTANCE_IN_MB}m\"" >>"${ENV_SH}"
    fi
    start_server "${conf}"
    server_name="`echo $SERVER_NAME | tr [A-Z] [a-z]`"
    if [ ${#EVENT_HOSTNAME[*]} = 0 ]; then
      echo "No dedicated hostname provided for reverse proxy mapping for event. Defaulting to server name ${server_name}" >>/var/log/sailing.err
      EVENT_HOSTNAME="${server_name}.sapsailing.com"
    fi
    if [ ${#SERIES_HOSTNAME[*]} = 0 ]; then
      echo "No dedicated hostname provided for reverse proxy mapping for series. Defaulting to server name ${server_name}" >>/var/log/sailing.err
      SERIES_HOSTNAME="${server_name}.sapsailing.com"
    fi
    reverse_proxy_config_file="$APACHE_CONFIG_DIR/${server_name}.conf"
    if [ $(( ${#EVENT_ID[*]} + ${#SERIES_ID[*]} )) = 0 ]; then
      # neither an EVENT_ID nor a SERIES_ID were provided; default to Home-SSL macro invocation:
      echo "## No event / series ID provided; forwarding domain to /gwt/Home.html" >>"${reverse_proxy_config_file}"
      echo "Use Home-SSL ${EVENT_HOSTNAME} 127.0.0.1 $SERVER_PORT" >>"${reverse_proxy_config_file}"
    else
      # Now loop over all EVENT_ID specification keys and produce an "Event-SSL" macro invocation for each:
      for i in ${!EVENT_ID[*]}; do
	echo "Appending macro invocation to ${reverse_proxy_config_file} to map ${EVENT_HOSTNAME[$i]} to event with ID ${EVENT_ID[$i]} with server running on local port $SERVER_PORT..." >>/var/log/sailing.err
	echo "## EVENT ${EVENT_HOSTNAME[$i]}" >>"${reverse_proxy_config_file}"
	echo "Use Event-SSL ${EVENT_HOSTNAME[$i]} \"${EVENT_ID[$i]}\" 127.0.0.1 $SERVER_PORT" >>"${reverse_proxy_config_file}"
      done
      # Now loop over all SERIES_ID specification keys and produce an "Series-SSL" macro invocation for each:
      for i in ${!SERIES_ID[*]}; do
	echo "Appending macro invocation to ${reverse_proxy_config_file} to map ${SERIES_HOSTNAME[$i]} to event with ID ${SERIES_ID[$i]} with server running on local port $SERVER_PORT..." >>/var/log/sailing.err
	echo "## SERIES ${SERIES_HOSTNAME[$i]}" >>"${reverse_proxy_config_file}"
	echo "Use Series-SSL ${SERIES_HOSTNAME[$i]} \"${SERIES_ID[$i]}\" 127.0.0.1 $SERVER_PORT" >>"${reverse_proxy_config_file}"
      done
    fi
    # terminating the subshell will forget all the variable assignments brought in by env.sh, clearing for the next server instance
  )
  RETVAL=$?
  [ $RETVAL -eq 0 ] && success || failure
}

stop_servers() {
	for conf in $JAVA_START_INSTANCES; do
		echo "Stopping Java server $conf" >> /var/log/sailing.err
		su - sailing -c "cd $SERVERS_DIR/$conf && ./stop"
		RETVAL=$?
		[ $RETVAL -eq 0 ] && success || failure
		stop_httpd
		sync_logs
	done
}

sync_logs() {
	echo "Executing logrotate followed by a sync to ensure that logs are synchronized" >> /var/log/sailing.err
	logrotate -f /etc/logrotate.conf
	sync
}

reload_httpd() {
	echo "Will try to launch httpd so this replica can work with an ELB easily." >>/var/log/sailing.err
	if [ -x /etc/init.d/httpd ]; then
	  echo "Reloading httpd configuration..." >>/var/log/sailing.err
	  service httpd reload
	else
	  echo "Can't launch httpd; start script doesn't seem to be installed at /etc/init.d/httpd"
	fi
}

# Adds a Plain-SSL mapping to the first server's port and a mapping for /internal-server-status, both to 001-internals.conf
create_basic_httpd_config() {
    FIRST_SERVER=`echo $JAVA_START_INSTANCES | awk '{print $1;}'`
    source $SERVERS_DIR/$FIRST_SERVER/env.sh
    echo "Writing macro invocation to ${APACHE_INTERNALS_CONFIG_FILE} to map internal IP $INSTANCE_INTERNAL_IP4 to plain server running $SERVER_PORT..." >>/var/log/sailing.err
    echo "Use Plain-SSL ${INSTANCE_INTERNAL_IP4} 127.0.0.1 $SERVER_PORT" >"${APACHE_INTERNALS_CONFIG_FILE}"
    # Append Apache macro invocation for /internal-server-status based on mod_status and INSTANCE_DNS to "${APACHE_INTERNALS_CONFIG_FILE}"
    echo "Appending macro usage for $INSTANCE_DNS/internal-server-status URL for mod_status based Apache monitoring to ${APACHE_INTERNALS_CONFIG_FILE}" >>/var/log/sailing.err
    echo "## SERVER STATUS" >>"${APACHE_INTERNALS_CONFIG_FILE}"
    echo "Use Status $INSTANCE_DNS internal-server-status" >>"${APACHE_INTERNALS_CONFIG_FILE}"
}

stop_httpd() {
	if [ -x /etc/init.d/httpd ]; then
		service httpd stop
		echo "Stopped httpd..." >>/var/log/sailing.err
	fi
}

# See how we were called.
case "$1" in
  start)
	start_servers
	/usr/sbin/update-motd
	touch /var/lock/subsys/sailing
    ;;
  stop)
	stop_servers
	rm -f /var/lock/subsys/sailing
	;;
  status)
	status java
	RETVAL=$?
	;;
  *)
    echo $"Usage: $0 {start|status|stop}"
    RETVAL=3
esac

exit $RETVAL
