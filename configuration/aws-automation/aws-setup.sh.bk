#!/usr/bin/env bash


# TODO: Parameter input by user
# 

# check if tmux package is installed
if ! type tmux >/dev/null 2>/dev/null; then
  echo "The package \"tmux\" is required to run this script"
fi

# check if the script is executed in a tmux environment
if ! { [ "$TERM" = "screen" ] && [ -n "$TMUX" ]; } then
  echo "Please run this script inside a tmux session. To do so enter \"tmux\" into the console and start the script from there."
  exit
fi 

export AWS_REGION=eu-west-2
export IMAGE_ID=ami-39f3e25d
export COUNT=1
export INSTANCE_TYPE=t2.medium
export KEY_NAME=leonradeck-keypair
export KEY_FILE=/cygdrive/c/Users/d069485/.ssh/leonradeck-keypair.pem
export SECURITY_GROUP_IDS=sg-871732ee
export USER_DATA=file://./userdata.txt
export SERVER_NAME_LONG=WCSantander2017
export SERVER_NAME_SHORT=wcs17
export TAG_SPECIFICATIONS='ResourceType=instance,Tags=[{Key=Name,Value=$SERVER_NAME}]'

export SSH_RETRY_INTERVAL_IN_SECONDS=2
export SSH_USER=root
export SSH_OK=ok

export HTTP_RETRY_INTERVAL_IN_SECONDS=5

export USERNAME=admin
export PASSWORD=admin
export CHANGED_PASSWORD=admin

export NEW_USERNAME=testuser
export NEW_PASSWORD=password

export HOST_ZONE_ID=Z1R8UBAEXAMPLE
export RECORD_FILE=file://C:\awscli\route53\change-resource-record-sets.json

# enable scrolling, clicking on panes etc.
tmux set -g mouse on

# enable named border at the top of panes
tmux set -g pane-border-status top
tmux set -g pane-border-format " [#{pane_index}] - #T "  

# construct pane layout
tmux split-window -h -p 50 
tmux select-pane -t 0
tmux split-window -v -p 50 
tmux select-pane -t 2 
tmux split-window -v -p 50 
tmux select-pane -t 0

# create parameterized instance and get instance id
echo "Creating instance..."
INSTANCE=`aws --region $AWS_REGION  ec2 run-instances \
--region $AWS_REGION \
--image-id $IMAGE_ID \
--count $COUNT \
--instance-type $INSTANCE_TYPE \
--key-name $KEY_NAME \
--security-group-ids $SECURITY_GROUP_IDS \
--user-data $USER_DATA \
--tag-specifications $TAG_SPECIFICATIONS`

echo "$INSTANCE"
SUBNET_ID=$(echo $INSTANCE | jq -r '.Instances[0].SubnetId' | tr -d '\r')
INSTANCE_ID=$(echo $INSTANCE | jq -r '.Instances[0].InstanceId' | tr -d '\r')
echo "Subnet: $SUBNET_ID" 

echo "Wait until instance is recognized by AWS..." 
aws ec2 wait instance-exists --instance-ids $INSTANCE_ID
echo "The instance is now recognized."

echo "Querying for the instance public dns name..." 
PUBLIC_DNS_NAME=`aws --region $AWS_REGION ec2 describe-instances --instance-ids $INSTANCE_ID --output text --query 'Reservations[*].Instances[*].PublicDnsName' | tr -d '\r'`
echo "The public dns name is: $PUBLIC_DNS_NAME"

echo "Wait until ssh connection is established..." 
status=not_ok
while [[ $status != ok ]]
do
  echo -n "."
  status=`ssh -q -o BatchMode=yes -o StrictHostKeyChecking=no -i $KEY_FILE $SSH_USER@$PUBLIC_DNS_NAME echo $SSH_OK 2>&1`
  sleep $SSH_RETRY_INTERVAL_IN_SECONDS
done
echo "SSH Connection is established."

echo "Started tailing logfiles on panes 1,2,3."

# open ssh connection on panes 1,2,3
tmux send-keys -t 1 "ssh -o StrictHostKeyChecking=no -i $KEY_FILE $SSH_USER@$PUBLIC_DNS_NAME" C-m
tmux send-keys -t 2 "ssh -o StrictHostKeyChecking=no -i $KEY_FILE $SSH_USER@$PUBLIC_DNS_NAME" C-m
tmux send-keys -t 3 "ssh -o StrictHostKeyChecking=no -i $KEY_FILE $SSH_USER@$PUBLIC_DNS_NAME" C-m

# tail some important files
tmux send-keys -t 1 "clear;echo \"Waiting for file /home/sailing/servers/server/logs/sailing0.log.0 to appear...\";tail -F -v /home/sailing/servers/server/logs/sailing0.log.0" C-m
tmux send-keys -t 2 "clear;tail -f -v /var/log/sailing.out" C-m
tmux send-keys -t 3 "clear;tail -f -v /var/log/sailing.err" C-m

echo "Wait until resource \"/security/api/restsecurity/access_token\" is available..."
while [[ "$(curl -s -o /dev/null -w ''%{http_code}'' http://$USERNAME:$PASSWORD@$PUBLIC_DNS_NAME:8888/security/api/restsecurity/access_token)" != "200" ]]; 
do sleep $HTTP_RETRY_INTERVAL_IN_SECONDS; 
done
echo "Resource \"/security/api/restsecurity/access_token\" is available."

echo "Getting access token..."
ACCESS_TOKEN=$(curl -X GET "http://$USERNAME:$PASSWORD@$PUBLIC_DNS_NAME:8888/security/api/restsecurity/access_token" | jq -r '.access_token' | tr -d '\r')
echo "Access token is: $ACCESS_TOKEN"

echo "Wait until resource \"/sailingserver/api/v1/events/createEvent\" is available..."
while [[ "$(curl -s -o /dev/null -w ''%{http_code}'' http://$PUBLIC_DNS_NAME:8888/sailingserver/api/v1/events/createEvent)" == "404" ]]; 
do sleep $HTTP_RETRY_INTERVAL_IN_SECONDS; 
done
echo "Resource \"/sailingserver/api/v1/events/createEvent\" is available."

echo "Creating event..."
EVENT_ID=$(curl -X POST -H "Authorization: Bearer $ACCESS_TOKEN" "http://$PUBLIC_DNS_NAME:8888/sailingserver/api/v1/events/createEvent" --data "venuename=Default" --data "createregatta=false" | jq -r '.eventid' | tr -d '\r')
echo "Created event wit id: $EVENT_ID"

echo "Changing admin password from $PASSWORD to $CHANGED_PASSWORD..."
curl -X POST -H "Authorization: Bearer $ACCESS_TOKEN" "http://$PUBLIC_DNS_NAME:8888/security/api/restsecurity/change_password" --data "username=$USERNAME" --data "password=$CHANGED_PASSWORD"
echo "Changed admin password."

echo "Creating new user \"$NEW_USERNAME\" with password \"$NEW_PASSWORD\"..."
curl -X POST -H "Authorization: Bearer $ACCESS_TOKEN" "http://$PUBLIC_DNS_NAME:8888/security/api/restsecurity/create_user" --data "username=$NEW_USERNAME" --data "password=$NEW_PASSWORD"
echo "Created user."
# ignore new user for the moment because updating its priviliges via rest is not yet implemented

# EVENT_SSL_LINE="Event-SSL $PUBLIC_DNS_NAME \"$EVENT_ID\" 127.0.0.1 8888"
# EVENTS_FILE="/etc/httpd/conf.d/001-events.conf"
# echo "Appending: $EVENT_SSL_LINE to file $EVENTS_FILE."
# ssh -o StrictHostKeyChecking=no -i $KEY_FILE $SSH_USER@$PUBLIC_DNS_NAME

# allocate elastic ip
# ELASTIC_IP=$(aws ec2 allocate-address | jq -r '.PublicIp' | tr -d '\r')

# associate elastic ip with instance 
# aws ec2 associate-address --instance-id $INSTANCE_ID --public-ip $ELASTIC_IP

# create elb
echo "Creating elastic load balancer..."
aws elb create-load-balancer --load-balancer-name $SERVER_NAME_LONG --listeners "Protocol=HTTP,LoadBalancerPort=80,InstanceProtocol=HTTP,InstancePort=80" --subnets $SUBNET_ID
echo "Created elastic load balancer."

# add instances to elb
echo "Adding instance to elb..."
aws elb register-instances-with-load-balancer --load-balancer-name $SERVER_NAME_LONG --instances $INSTANCE_ID
echo "Added instance."

# create change-resource-record-set file
 
# create Route53 entry for elb
# aws route53 change-resource-record-sets --hosted-zone-id $HOST_ZONE_ID --change-batch $RECORD_FILE
