# Working with GWT UI Binder

[[_TOC_]]

## Introduction

The GWT UI Binder technology uses HTML-like documents to describe the structure and static content of the UI. See the tutorial here: http://www.gwtproject.org/doc/latest/DevGuideUiBinder.html. With UI Binder, widgets are developed by declaring the widget's static HTML content in a `.ui.xml` file that more or less looks like HTML. By naming convention, a corresponding class related to the `.ui.xml` file. The class can bind its fields to elements in the `.ui.xml` file using Java annotations such as `@UiField`, matching with `ui:field` attributes in the `.ui.xml` file.

In the `.ui.xml` flie, elements can be used to represent widgets. In particular, all predefined GWT widgets are usually mapped to the `g:` namespace and can be used as in `<g:FlowPanel ui:field="someFieldName" />`. This will bind an instance of type `FlowPanel` to the widget class's field named `someFieldName` which has to be of type `com.google.gwt.user.client.ui.FlowPanel`.

## The Design and Development Process with Ubilabs

We chose to work with a partner for UI Design: Ubilabs in Hamburg, Germany. They use a framework called Jade for their Web development. Their git repository lives at `https://<yourgithubuser>@github.com/ubilabs/sap-sailing-analytics.git`. The output of the Ubilabs build process is a bunch of HTML files (matching the "partials" component structure used in Jade) and the corresponding CSS files. Ubilabs plans to commit this generated output regularly to their git repository so we can understand the changes that we need to map into our environment.

As Ubilabs does not use GWT, we need to map their build outputs to our GWT architecture. GWT UI Binder fits with this goal. For each Jade partial we develop a corresponding UI Binder widget. The CSS file generated by Ubilabs can be used as is for the UI Binder widget. The HTML file needs to be renamed to `.ui.xml` and its contents need to be adjusted to the UI Binder styles and elements.

Ubilabs will deliver two versions of the site: one for use on desktops and tablets, and another for smartphone use. We need to map both versions to GWT UI Binder and decide based on the user agent and viewport size which one to choose.

## Internationalization (i18n)

We're not yet decided on how to implement i18n. GWT offers two mechanisms that seem viable, see http://www.gwtproject.org/doc/latest/DevGuideUiBinderI18n.html. We could use GWT's feature that generates the property files. The upside would be that in case of many static texts we would get a quick start. The generation of UUIDs from the original static texts additionally ensures that changes cause compile errors and hence notify us that re-translation is required, which is good.

The downside is that redundancies across different entry points are not handled well and that the property files may not fit in well with programmatic use of those message strings.

Alternatively, it is possible to declare the string messages class and the method name that shall be used for the string message property. This way, we could consolidate all texts into a single message properties file which may help avoid redundancies.

We'll probably try out both approaches in a small scale and then decide.

## GWT Code Splitting

For the various areas of the site we don't always want to have to load a new page. Instead, we'd like to use the "places" pattern with a local history management. This goes together well with GWT Code Splitting (see http://www.gwtproject.org/doc/latest/DevGuideCodeSplitting.html#patterns) which allows an application to load its parts when they are needed. This speeds up the initial loading process and keeps bandwidth consumption low. We use the Gin framework to support us in this.

## About GWTP and the Gin Framework and how We Use Them

GWPT (https://github.com/ArcBees/GWTP and https://github.com/arcbees/gwtp/wiki) is a model-view-presenter framework that uses Gin (GWT INjection, see https://code.google.com/p/google-gin/ and the tutorial at https://code.google.com/p/google-gin/wiki/GinTutorial) as an underlying framework for GWT-based dependency injection.

### Our Bundle and Package Structure

The key bundle to the GWT UI Binder-based site is `com.sap.sailing.gwt.home`. The key module is described in `src/main/resources` under `com/sap/sailing/gwt/home/Home.gwt.xml`. It contains configuration entries of the form

<pre>
    &lt;set-configuration-property name="gin.ginjector.module.desktop"
                                value="com.sap.sailing.gwt.home.client.gin.DesktopModule" /&gt;
    &lt;set-configuration-property name="gin.ginjector.module.mobile"
                                value="com.sap.sailing.gwt.home.client.gin.MobileModule" /&gt;
    &lt;set-configuration-property name="gin.ginjector.module.tablet"
                                value="com.sap.sailing.gwt.home.client.gin.TabletModule" /&gt;
</pre>

which instructs Gin to activate the modules mentioned for the respective type of user agent (desktop, mobile, tablet). Each such module implementation is trivial, as seen in the desktop module:

<pre>
public class DesktopModule extends AbstractPresenterModule {
    @Override
    protected void configure() {
        install(new ApplicationDesktopModule());
    }
}
</pre>

As the example shows, the presenter module redirects by installing another module, showing that modules can be nested. A nested module, such as `ApplicationDesktopModule` then binds views to presenters, as in

<pre>
        bindPresenter(StartPagePresenter.class, StartPagePresenter.MyView.class, StartPageView.class,
                StartPagePresenter.MyProxy.class);
</pre>

Note the use of `MyProxy`. This is where GWT's code splitting capability comes into play.

### Basic Use of GWTP

The basic principles of GWTP suggest the use of a presenter, a view and a proxy that act together as a component. The view implements an interface declared in the presenter, usually called `MyView` which among other things may allow the presenter to update data to the view.

The view class finally binds the GWTP component to the UI Binder logic. It extends some `Widget` subclass and implements the view interface declared by the presenter. The view class also defines a `UiBinder` subinterface which is used in a call to `GWT.create(...)`. Here is an example:

<pre>
public class EventsPageView extends Composite implements EventsPagePresenter.MyView {
    private static EventsPageViewUiBinder uiBinder = GWT.create(EventsPageViewUiBinder.class);

    interface EventsPageViewUiBinder extends UiBinder<Widget, EventsPageView> {
    }

    ...

    @Inject
    public EventsPageView(PlaceManager placeManager) {
        super();
        ... // initialize component and fields
        initWidget(uiBinder.createAndBindUi(this));
        ... // do more stuff after widget has been bound to .ui.xml
    }
</pre>