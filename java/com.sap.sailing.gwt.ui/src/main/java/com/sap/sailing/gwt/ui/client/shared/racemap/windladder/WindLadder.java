package com.sap.sailing.gwt.ui.client.shared.racemap.windladder;

import com.google.gwt.maps.client.MapWidget;
import com.sap.sailing.domain.common.Position;
import com.sap.sailing.gwt.ui.client.shared.racemap.CoordinateSystem;
import com.sap.sailing.gwt.ui.shared.WindDTO;

/**
 * <p>Main WindLadder component.</p>
 * <p>This class controls multiple instances of {@link WindLadderOverlay} which perform the actual rendering. Because of
 * limitations imposed by the animation system, animations which are not possible are achieved by quickly swapping to a
 * different overlay instance. This is handled by {@link DoubleCanvasBuffer}.</p>
 * <p>The actual image rendered to screen is created by arranging an image tile generated by {@link ImageTileGenerator}
 * in a screen covering, repeating pattern.</p>
 * <p>The main data flow runs through the {@link #update} method which then dispatches that data to one of the
 * canvases in {@link DoubleCanvasBuffer#buffer}.</p>
 * 
 * @author Tim Hessenm√ºller (D062243)
 *
 */
public class WindLadder extends DoubleCanvasBuffer<WindLadderOverlay> {
    protected CoordinateSystem coordinateSystem;

    protected Double windBearingRadians;
    protected Position fixPosition;
    protected long transitionTime;

    protected Double previousWindBearingRadians;
    protected Position previousFixPosition;

    /**
     * When set the next {@link #update} will perform a swap;
     */
    protected boolean forceSwap;
    /**
     * When set a swap has been initiated and will be completed on the next {@link #update}
     */
    protected boolean doSwap;

    public WindLadder(MapWidget map, int zIndex, CoordinateSystem coordinateSystem) {
        super();
        this.coordinateSystem = coordinateSystem;
        this.buffer = new WindLadderOverlay[BUFFER_SIZE];
        this.buffer[0] = new WindLadderOverlay(this, map, zIndex, coordinateSystem);
        this.buffer[1] = new WindLadderOverlay(this, map, zIndex, coordinateSystem);
        this.apply(overlay -> overlay.setVisible(false));
        this.setVisible(true);
        this.addToMap();
    }

    protected void forceSwap() {
        forceSwap = true;
    }

    public void update(WindDTO windFix, Position fixPosition, long timeForPositionTransitionMillis) {
        // Update previous* values
        previousWindBearingRadians = this.windBearingRadians; //TODO Check for off-by-one error regarding swap method
        previousFixPosition = this.fixPosition;
        // Update current values
        if (windFix != null) {
            windBearingRadians = Math.toRadians(coordinateSystem.mapDegreeBearing(windFix.trueWindFromDeg));
        }
        if (fixPosition != null) {
            this.fixPosition = fixPosition;
        }
        this.transitionTime = timeForPositionTransitionMillis;
        if (doSwap) {
            doSwap();
            doSwap = false;
        }
        // Check if swap is required
        boolean swapRequired = !getActiveCanvas().update(windBearingRadians, fixPosition, timeForPositionTransitionMillis);
        if (forceSwap || swapRequired) {
            swap();
            forceSwap = false;
        }
    }

    /**
     * Starts up the next canvas and schedules a swap during the next {@link #update} call.
     */
    @Override
    public void swap() {
        // Update next canvas, to where the active canvas will be stopping, before swapping during the next update
        WindLadderOverlay next = this.buffer[nextCanvasIndex()];
        next.update(previousWindBearingRadians, previousFixPosition, transitionTime, /* redraw */ true);
        this.doSwap = true;
    }

    /**
     * Actually swaps the canvases.
     */
    public void doSwap() {
        super.swap();
    }
}
