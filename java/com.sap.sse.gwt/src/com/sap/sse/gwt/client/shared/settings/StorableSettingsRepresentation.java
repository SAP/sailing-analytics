package com.sap.sse.gwt.client.shared.settings;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.google.gwt.core.client.GWT;
import com.google.gwt.json.client.JSONObject;
import com.google.gwt.json.client.JSONParser;
import com.google.gwt.json.client.JSONValue;
import com.sap.sse.common.settings.Settings;

/**
 * Represents a generic representation of settings. Its used as a layer between
 * {@link com.sap.sse.common.settings.Settings Settings} object and persistence layer.
 * 
 * @author Vladislav Chumak
 *
 */
public class StorableSettingsRepresentation {

    private final JSONObject internalSettingsRepresentation;

    /**
     * 
     * @param settingsJsonRepresentation
     *            The representation of settings generated by using {@link #asJson()}. May not
     *            be {@code null}.
     */
    public StorableSettingsRepresentation(JSONObject settingsJsonRepresentation) {
        this.internalSettingsRepresentation = settingsJsonRepresentation;
    }

    /**
     * 
     * @param settingsStringRepresentation
     *            The representation of settings generated by using {@link #asString()}. May
     *            not be {@code null}.
     */
    public StorableSettingsRepresentation(String settingsStringRepresentation) {
        this.internalSettingsRepresentation = (JSONObject) JSONParser.parseStrict(settingsStringRepresentation);
    }

    /**
     * 
     * @return The representation of settings as JSON. Cannot be {@code null}.
     */
    public JSONObject asJson() {
        return internalSettingsRepresentation;
    }

    /**
     * 
     * @return The representation of settings as String. Cannot be {@code null}.
     */
    public String asString() {
        if(internalSettingsRepresentation != null) {
            return internalSettingsRepresentation.toString();
        } else {
            return "{}";
        }
    }
    
    /**
     * Patches the settings tree with the new settings provided. The settings node with the provided path is going to be
     * created/replaced with the new settings.
     * 
     * @param root
     *            The root node of the settings tree
     * @param path
     *            The path of the node to create/update
     * @param newSettings
     *            The new settings with that the target node in the settings tree is going to be updated
     * @param pipelineLevel
     *            The scope of settings used for settings storage (e.g. User Settings, or Document Settings)
     * @return The patched storable settings representation
     */
    public static StorableSettingsRepresentation patchSettingsRepresentation(StorableSettingsRepresentation root,
            List<String> path, StorableSettingsRepresentation newSettings) {
        JSONObject patchedSettingsJsonRepresentation = patchJsonObject(root == null ? null : root.asJson(), path,
                Collections.unmodifiableList(new ArrayList<>(path)), newSettings==null?null:newSettings.asJson());
        return new StorableSettingsRepresentation(patchedSettingsJsonRepresentation);
    }
    
    /**
     * Internal helper method for
     * {@link #patchSettingsRepresentation(StorableSettingsRepresentation, List, Settings, PipelineLevel)}
     * 
     * @param root
     * @param path
     * @param originalPath
     * @param newSettings
     * @param pipelineLevel
     * @return
     */
    private static JSONObject patchJsonObject(JSONObject root, List<String> path, List<String> originalPath,
            JSONObject newSettings) {
        if (path.isEmpty()) {
            return newSettings;
        }
        if (root == null) {
            root = new JSONObject();
        }
        String current = path.remove(path.size() - 1);
        // we need to go further
        if (!path.isEmpty()) {
            JSONValue child = root.get(current);
            boolean haskey = root.containsKey(current);
            if (child == null || child.isObject() == null) {
                if (haskey) {
                    GWT.log("Warning: replacing some subtree element that is wrong type!");
                }
                if(newSettings == null){
                    //no need to create tree, if we only want to remove settings!
                    return null;
                }
                child = new JSONObject();
                root.put(current, child);
            }
            return patchJsonObject(child.isObject(), path, originalPath, newSettings);
        } else {
            root.put(current, newSettings);
        }
        return root;
    }
    
    public StorableSettingsRepresentation getSubSettingsRepresentation(List<String> subPath) {
        return new StorableSettingsRepresentation(getSubSettingsRepresentation(internalSettingsRepresentation, new ArrayList<>(subPath)));
    }
    
    public static JSONObject getSubSettingsRepresentation(JSONObject root, List<String> subPath) {
        if (subPath.isEmpty()) {
            return root;
        } else {
            String current = subPath.remove(subPath.size() - 1);
            // we need to go further
            JSONValue child = root.get(current);
            boolean haskey = root.containsKey(current);
            if (child == null || child.isObject() == null) {
                if (haskey) {
                    GWT.log("Warning: replacing some subtree element that is wrong type!");
                }
                child = new JSONObject();
            }
            return getSubSettingsRepresentation(child.isObject(), subPath);
        }
    }

}
