#!/bin/bash
# Call like this:    analyzeProduct.sh <my.product> [<my.launch> ...]
# Updates Eclipse .launch files with the bundles needed for starting an SAP Sailing server based on the current feature.xml.
# The .launch files must be in the workspace format that was introduced with Eclipse 2019-12. The script prints an error when no matching
# replacement section could be found.
# Will output two sections in format
#     <setAttribute key="selected_target_bundles">
#          <setEntry value="com.fasterxml.jackson.core.jackson-annotations@default:default"/>
#          <setEntry value=".....
#     </setAttribute>
#     <setAttribute key="selected_workspace_bundles">
#          <setEntry value="com.google.gwt.servlet@default:default"/>
#          <setEntry value=".....
#     </setAttribute>
# If one or more launch configuration files are provided as the remaining arguments, they will be patched in-place by
# replacing the selected_workspace_bundles and selected_target_bundles string attributes by those generated by this script.
# If the launch configuration's name contains the sub-string winddbTest, the additional bundle
#              com.sap.sailing.server.gateway.test.support@default:default
# is added to the workspace-bundles string.

# The product consists of the features and plugins it lists. Its <configuration> section overrides
# the startLevel and autoStart defaults (4 / false) for a subset of the bundle list obtained from
# the features and plugins lists. The features that our product consists of are partitioned into
# ".runtime" and non-".runtime" features. The ".runtime" features obtain their bundles from the
# target platform, whereas the non-".runtime" features take their features from the workspace.

# In order to derive the target/workspace bundles for a launch configuration, the bundles are
# extracted from the features. Those from the .runtime features are assigned to the target_bundles
# attribute, the others to the workspace_bundles attribute. Auto start and start level information
# will be set to default:default unless the bundle occurs in the <configuration> section of the
# .product definition in which case the start level and auto start values are copied from the
# .product's <configuration> section.
NL=$'\n'
GIT_ROOT=`dirname $0`/../../..
echo "GIT ROOT: $GIT_ROOT"
features=$(cat "$1" | grep "feature id=" | sed -e 's/^.*feature id="\([^"]*\)".*$/\1/')
echo ' *** Features ***'
echo "$features"
feature_xml_files=$(for i in $features; do echo "${GIT_ROOT}/java/$i/feature.xml"; done)
echo "$feature_xml_files"
# Determine the bundles with a specific configuration in the .product file:
autostart_bundles=$(cat "$1" | grep "plugin id=.* startLevel=" | sed -e 's/^.* id="\(.*\)" autoStart="\(.*\)" startLevel="\([0-9-]*\)".*$/\1 \3 \2/')
echo ' *** Autostart Bundles ***'
echo "$autostart_bundles"
# These autostart bundles need to be updated accordingly in the .launch configuration
# so they have the correct startLevel and autostart settings. The autostart bundles
# may occur either in the target_bundles or the workspace_bundles attribute in the .launch
# configuration. All other entries in the .launch configuration are set to @default:default.
# Now collect the bundles from the feature.xml files, split by workspace vs. target:
for feature in $features; do
    feature_xml_file=${GIT_ROOT}/java/$feature/feature.xml
    bundles_in_feature=$(cat "$feature_xml_file" | grep "id=\"" | grep -v "id=\"$feature\"" | sed -e 's/^.*id="\([^"]*\)".*$/\1/')
    echo ' *** Bundles in feature' $feature '***'
    echo "$bundles_in_feature"
    for bundle in $bundles_in_feature; do
        # find out whether we have a non-default configuration for the bundle
        echo "$autostart_bundles" | grep -q '^'${bundle}' [^ ]* true$'
        if [ "$?" == "0" ]; then
            # found a configuration for the bundle
            echo ' *** Found a non-default configuration for bundle '${bundle}' ***'
            bundle_spec_for_launch=$(echo "$autostart_bundles" | grep '^'${bundle}' [^ ]* [^ ]*$' | sed -e 's/^\([^ ]*\) \([^ ]*\) \([^ ]*\)$/\1@\2:\3/')
        else
            bundle_spec_for_launch="${bundle}@default:default"
        fi
        if [[ $feature =~ .runtime$ ]]; then
            # contribute to target_bundles
            target_bundles="${target_bundles}${NL}<setEntry value=\"${bundle_spec_for_launch}\"\/>"
        else
            # contribute to workspace_bundles
            workspace_bundles="${workspace_bundles}${NL}<setEntry value=\"${bundle_spec_for_launch}\"\/>"
        fi
    done 
done
echo ' *** Target Bundles ***'
echo "${target_bundles}"
echo ' *** Workspace Bundles ***'
echo "${workspace_bundles}"
# Now patch the .launch file if provided
while [ "$2" != "" ]; do
    if grep -q key=\"target_bundles\" "$2"; then
        echo "Not patching $2  ... please use script for eclipse 2019-09 or older"
    else
        echo "Patching $2 ..."
        if echo "$2" | grep -q winddbTest; then
          patched_workspace_bundles="${workspace_bundles}${NL}<setEntry value=\"com.sap.sailing.server.gateway.test.support@default:default\"\/>${NL}"
        else
          patched_workspace_bundles="${workspace_bundles}"
        fi
        selected_target_bundles="<setAttribute key=\"selected_target_bundles\">${target_bundles}${NL}<\/setAttribute>"
        patched_workspace_bundles="<setAttribute key=\"selected_workspace_bundles\">${patched_workspace_bundles}${NL}<\/setAttribute>"
		# Used Perl CLI options:
		#0 -> specifies the record separator, as you alread found out, it defaults to \0 so it does not terminate before the end of the text file. Ensures that the regular expression is applied over the whole file.
		#p -> apply looping wrapper, see perl man page
		#e -> denotes the (regular) expression that is goint ot be applied.
		#i -> inplace editing of files
        perl -i -p0e "s/<setAttribute key=\"selected_target_bundles\">.*?<\/setAttribute>/${selected_target_bundles}/s" "$2"
        perl -i -p0e "s/<setAttribute key=\"selected_workspace_bundles\">.*?<\/setAttribute>/${patched_workspace_bundles}/s" "$2"
		# remove eventuelly created bak files (this happens at least on windows platform)
		rm "$2.bak"
    fi
    shift
done
